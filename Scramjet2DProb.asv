%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2D Scramjet Flight
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%===================
% Problem variables:
%-------------------
% states = x, y, vx, vy, theta, omega
% controls = tau, Mc
%===================

%---------------------------------------
% bounds the state and control variables
%---------------------------------------

xL = 0; xU = 100.;
yL = 0; yU = 100.;
vxL = 0; vxU = 400.;
vyL = 0; vyU = 400.;
thetaL = 0; thetaU = 2.; %these will need to be adjusted, currently arbitrary
omegaL = 0; omegaU = 1.;


bounds.lower.states = [xL; yL; vxL; vyL; thetaL; omegaL];
bounds.upper.states = [xU; yU; vxU; vyU; thetaU; omegaU];

bounds.lower.controls = [0; 0];
bounds.upper.controls = [1000; 100]; %these are placeholders, will need to be changed

%------------------
% bound the horizon
%------------------
t0	    = 0;
tfMax 	= 10;   % swag for max tf; DO NOT set to Inf even for time-free problems

bounds.lower.time 	= [t0; t0];				
bounds.upper.time	= [t0; tfMax];			    % Fixed time at t0 and a possibly free time at tf


%-------------------------------------------
% Set up the bounds on the endpoint function
%-------------------------------------------
% See events file for definition of events function

%Scaling, need to make these global variables!
global X
global Y
X = 1
Y = 1

%Scaling tests
% bounds.lower.events = [0; 0; 2; 2; 100/X; 100/Y; 2 ; 2]; %works with
% X,Y,T =100, or all 10
% bounds.lower.events = [0; 0; 10; 10; 100/X; 100/Y; 10 ; 10];
bounds.lower.events = [0; 0; 10/X; 10/Y];

% bounds.lower.events = [0; 0; 1; 1; 10/X; 10/Y; 1 ; 1];
bounds.upper.events = bounds.lower.events;      % equality event function bounds
% bounds.upper.events = [0; 0; 2; 2; 10/X; 10/Y; 3 ; 3];

%============================================
% Define the problem using DIDO expresssions:
%============================================
Brac_1.cost 		= 'Scramjet2DCost';
Brac_1.dynamics	    = 'Scramjet2DDynamics';
Brac_1.events		= 'Scramjet2DEvents';		
%Path file optional	

Brac_1.bounds       = bounds;
%====================================================

% Dont know how this changes the output yet...
algorithm.nodes		= [60];					    % represents some measure of desired solution accuracy

% Call dido
tStart= cputime;    % start CPU clock 
[cost, primal, dual] = dido(Brac_1, algorithm);
runTime = cputime-tStart
% Ta da!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          OUTPUT             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




h = primal.states(1,:);
v = primal.states(2,:);
vh = primal.states(3,:);
vv = primal.states(4,:);
theta = primal.states(5,:);
omega = primal.states(6,:);

t = primal.nodes;

tau = primal.controls(1,:);
Mc = primal.controls(2,:);


figure(1)
subplot(3,3,1)
plot(h,v)
title('h-v')
subplot(3,3,2)
plot(t, vh)
title('vh')
subplot(3,3,3)
plot(t, vv)
title('vv')

subplot(3,3,4)
plot(t, theta)
title('theta')
subplot(3,3,5)
plot(t, omega)
title('omega')
subplot(3,3,6)
plot(t, Mc)
title('Mc')
subplot(3,3,7)
plot(t, tau)
title('tau')

lam1 = dual.dynamics(1,:);
lam2 = dual.dynamics(2,:);
lam3 = dual.dynamics(3,:);
lam4 = dual.dynamics(4,:);

subplot(3,3,8);
plot(t, [lam1; lam2; lam3; lam4]);
title('costates')
xlabel('time');
ylabel('costates');
legend('\lambda_1', '\lambda_2', '\lambda_3', '\lambda_4');

subplot(3,3,9)
H = dual.Hamiltonian(1,:);
plot(t,H);
title('Hamiltonian')



%------ Forward Simulation -----------

% Import Controls 
% these are the only things carried over from the PS method
tau_Forward = tau;
Mc_Forward = Mc
%--------------


Iy_Forward = 1.;
m_Forward = 1000.;

Fx_Forward = 0.; %Taking these out for testing
Fz_Forward = 0.;
My_Forward = 0.;





for i=1:length(Mc_Forward)
omegadot_Forward = (My_Forward  + Mc_Forward(i))/Iy_Forward;


thetadot_Forward = omega_Forward;
    
vhdot_Forward = (Fx_Forward.*cos(theta_Forward) + Fz_Forward.*sin(theta_Forward)  + tau_Forward(i).*cos(theta_Forward))/m_Forward;
vvdot_Forward = (-Fx_Forward.*sin(theta_Forward) + Fz_Forward.*cos(theta_Forward)  + tau_Forward(i).*sin(theta_Forward))/m_Forward;



end














