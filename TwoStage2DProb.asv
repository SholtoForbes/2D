%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 2D Scramjet Flight
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear all;		
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%velocity primal
% global v

% Inputs ============================================

communicator = importdata('communicatornew.txt');
% communicator = importdata('communicator.txt');

communicator_trim = importdata('communicator_trim.txt');
% communicator_trim = importdata('communicator_trim_extrapolate.txt');

%this produces simple splines for vehicle data
global AoA_spline
global flapdeflection_spline
global Dragq_spline
[AoA_spline, flapdeflection_spline, Dragq_spline] = LiftForceInterp(communicator,communicator_trim);


%engine splines for thrust and fuel usage
enginedata = dlmread('engineoutput_matrix');

global ThrustF_spline
ThrustF_spline= scatteredInterpolant(enginedata(:,1),enginedata(:,2),enginedata(:,3)); %interpolator for engine data (also able to extrapolate badly)
global FuelF_spline
FuelF_spline= scatteredInterpolant(enginedata(:,1),enginedata(:,2),enginedata(:,4)); %interpolator for engine data



%=============================================== 
%Second Stage
V0 = 20000.; % Keep initial values zero
Vf = 40000.; % Final values here are for guess and bounds, need to be fairly accurate

H0 = 0.;
Hf = 700000.;

v0 = 1864.13; % 50kpa q at 27000m
vf = 2979.83; % 50kpa q at 33000m

%dawids results have around 1 degree or under flight path angle
%===================
% Problem variables:
% control factor: omega
% variable trajectory
%===================

%========================================================

%---------------------------------------
% bound and scale the state and control variables
%---------------------------------------

VL = -1.;
VU = 1.0*Vf; 

HL = -1.;
HU = 1.2*Hf;

vL = 1500;
vU = 3100; % This limit must not cause the drag force to exceed the potential thrust of the vehicle, otherwise DIDO will not solve

% thetaL = -.2; %  NEED TO WATCH THAT THIS IS NOT OVERCONSTRAINING
% thetaU = 1.6;

% thetaL = -0.1; %  NEED TO WATCH THAT THIS IS NOT OVERCONSTRAINING
thetaL = 0.;
% thetaU = 0.26; %15 degrees
thetaU = 0.26/2;
% thetaU = 0.4; 


mfuelL = -3000;
mfuelU = 2000; % 

QL = 0;
% QU = 100*10^6; %joules, estimate
QU = 50*10^6; %this should limit the max heat

bounds.lower.states = [VL ; vL; thetaL; mfuelL];
bounds.upper.states = [VU ; vU; thetaU; mfuelU];

% control bounds

% thetadotL = -0.05;
% thetadotU = 0.05;

thetadotL = -0.02;
thetadotU = 0.02;

bounds.lower.controls = [thetadotL];
bounds.upper.controls = [thetadotU]; 




%------------------
% bound the horizon
%------------------
% time bounds, this is unscaled

t0	    = 0;
tfMax 	= Hf/1500;   %  max tf; DO NOT set to Inf even for time-free problems % remember to set higher than Vmax bounds min time

bounds.lower.time 	= [t0; t0];				
bounds.upper.time	= [t0; tfMax];




%-------------------------------------------
% Set up the bounds on the endpoint function
%-------------------------------------------
% See events file for definition of events function

% bounds.lower.events = [v0; vf; mfuelU];
bounds.lower.events = [v0; vf; mfuelU; QL; QU];

bounds.upper.events = bounds.lower.events;      % equality event function bounds



% bounds.lower.path = [QL];
% bounds.upper.path = [QU]; 


% PATH BOUNDS IF NECESSARY


%============================================
% Define the problem using DIDO expresssions:
%============================================
Brac_1.cost 		= 'TwoStage2DCost';
Brac_1.dynamics	    = 'TwoStage2DDynamics';
Brac_1.events		= 'TwoStage2DEvents';	
% Brac_1.path         = 'TwoStage2DPath';
%Path file optional	

Brac_1.bounds       = bounds;


% Node Definition ====================================================

algorithm.nodes		= [90];	


global nodes

nodes = algorithm.nodes;


%  Guess =================================================================

tfGuess = tfMax; % this needs to be close to make sure solution stays withing Out_Force bounds


guess.states(1,:) = [0 ,Vf]; %V
% guess.states(1,:) = [25000 ,25000]; %V

guess.states(2,:) = [v0, vf]; %v
guess.states(3,:) = [atan((Vf-V0)/(Hf-H0)),atan((Vf-V0)/(Hf-H0))]; 
% guess.states(3,:) = [0,0]; 

guess.states(4,:) = [mfuelU, mfuelU/2];

guess.states(5,:) = [0, 40*10^6];


guess.controls(1,:)    = [0,0]; 


guess.time        = [t0 ,tfGuess];



% Tell DIDO the guess.  Note: The guess-free option is not available when
% using "knots"
%========================
algorithm.guess = guess;
% algorithm.guess = primal_old;
% %========================
% algorithm.mode = 'accurate';
%=====================================================================================


% count

% Call dido
% =====================================================================
tStart= cputime;    % start CPU clock 
[cost, primal, dual] = dido(Brac_1, algorithm);
runTime = cputime-tStart
% ===================================================================
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%          OUTPUT             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

global dfuel
dfuel

V = primal.states(1,:);

v = primal.states(2,:);

t = primal.nodes;

% theta = primal.controls(1,:);

theta = primal.states(3,:);
thetadot = primal.controls(1,:);
% 
mfuel = primal.states(4,:);

% Q = primal.states(5,:);

% theta = primal.controls(1,:);

% mfuel = primal.states(3,:);

%calculating for interest
% c = 300.; % this will need to be brought into line with vehicle model

% M = v./ScaleFactor/c;
global M
% global v_array
% v_array
global q
global Fd
global Fueldt

global Thrust
global flapdeflection
global Alpha
global ThirdStagePayloadMass

global heating_rate
global Q

dt = t(2:end)-t(1:end-1); % Time change between each node pt
FuelUsed = zeros(1,nodes-1);
FuelUsed(1) = dt(1)*Fueldt(1);
for i = 2:nodes-1
    FuelUsed(i) = dt(i).*Fueldt(i) + FuelUsed(i-1);
end


% figure out horizontal motion
H(1) = 0;
for i = 1:nodes-1
H(i+1) = v(i)*(t(i+1) - t(i))*cos(theta(i)) + H(i);
end

figure(1)

subplot(5,5,[1,5])
hold on
plot(H, V)
plot(H(algorithm.nodes(1)), V(algorithm.nodes(1)), '+', 'MarkerSize', 10, 'MarkerEdgeColor','r')
title('Trajectory')

subplot(5,5,6)
hold on
plot(t, v)
plot(t(algorithm.nodes(1)), v(algorithm.nodes(1)), '+', 'MarkerSize', 10, 'MarkerEdgeColor','r')
title('v')


subplot(5,5,7)
plot(t, M)
title('M')

subplot(5,5,8)
plot(t, q)
title('q')

subplot(5,5,9)
hold on
plot(t, rad2deg(theta))
plot(t(algorithm.nodes(1)), rad2deg(theta(algorithm.nodes(1))), '+', 'MarkerSize', 10, 'MarkerEdgeColor','r')
title('theta (Deg)')

subplot(5,5,13)
hold on
plot(t, rad2deg(thetadot))
title('thetadot (Deg/s)')

subplot(5,5,19)
plot(t, mfuel)
title('fuel mass')

subplot(5,5,10)
plot(t, Fd)
title('Drag Force')

subplot(5,5,14)
hold on
plot(t(1:end-1), FuelUsed)
bar(t(end), ThirdStagePayloadMass)
title('Fuel and Payload Mass')

subplot(5,5,11);
plot(t, dual.dynamics);
title('costates')
xlabel('time');
ylabel('costates');
legend('\lambda_1', '\lambda_2', '\lambda_3');

subplot(5,5,12)
Hamiltonian = dual.Hamiltonian(1,:);
plot(t,Hamiltonian);
title('Hamiltonian')

subplot(5,5,15)
plot(t, Thrust)
title('Thrust (N)')

Isp = Thrust./Fueldt./9.81;

subplot(5,5,16)
plot(t, Isp)
title('Isp')

subplot(5,5,17)
plot(t, flapdeflection)
title('flapdeflection')

subplot(5,5,18)
plot(t, Alpha)
title('Alpha')



figure(2)
subplot(2,6,[1,6])
hold on
plot(H, V,'Color','k')

title('Trajectory')
xlabel('Horizontal Position (m)')
ylabel('Vertical Position (m)')

for i = 1:floor(t(end)/30)
    [j,k] = min(abs(t-30*i));
    str = strcat(num2str(round(t(k))), 's');
    text(H(k),V(k),str,'VerticalAlignment','top', 'FontSize', 10);
    
    plot(H(k), V(k), '+', 'MarkerSize', 10, 'MarkerEdgeColor','k')
end

plot(H(end), V(end), 'o', 'MarkerSize', 10, 'MarkerEdgeColor','k')


text(H(end),V(end),'Third Stage Transition Point','VerticalAlignment','top', 'FontSize', 10);

dim = [.65 .45 .2 .2];
annotation('textbox',dim,'string',{['Payload Mass: ', num2str(ThirdStagePayloadMass), ' kg'],['Second Stage Fuel Used: ' num2str(2000 - mfuel(end)) ' kg']},'FitBoxToText','on');  

thirdstageexample_H = [0+H(end) (H(end)-H(end - 1))+H(end) 20*(H(end)-H(end - 1))+H(end) 40*(H(end)-H(end - 1))+H(end) 60*(H(end)-H(end - 1))+H(end) 80*(H(end)-H(end - 1))+H(end)]; %makes a small sample portion of an arbitrary third stage trajectory for example
thirdstageexample_V = [0+V(end) (V(end)-V(end - 1))+V(end) 20*((V(end)-V(end -1)))+V(end) 40*((V(end)-V(end -1)))+V(end) 60*((V(end)-V(end -1)))+V(end) 80*((V(end)-V(end -1)))+V(end)];
plot(thirdstageexample_H, thirdstageexample_V, 'LineStyle', '--','Color','k');

hold on
subplot(2,6,[7,9])
xlabel('time (s)')

hold on
ax1 = gca; % current axes


line(t, rad2deg(theta),'Parent',ax1,'Color','k', 'LineStyle','-')

line(t, M,'Parent',ax1,'Color','k', 'LineStyle','--')



line(t, v./(10^3),'Parent',ax1,'Color','k', 'LineStyle','-.')


line(t, q./(10^4),'Parent',ax1,'Color','k', 'LineStyle',':', 'lineWidth', 2.0)

% line(t, heating_rate./(10^5),'Parent',ax1,'Color','k', 'LineStyle',':', 'lineWidth', 2.0)
% 
% line(t, Q./(10^7),'Parent',ax1,'Color','k', 'LineStyle','-', 'lineWidth', 2.0)

legend(ax1,  'Trajectory Angle (degrees)', 'Mach no', 'Velocity (m/s x 10^3)', 'Dynamic Pressure (Pa x 10^4)', 'heating rate (kw x 100)', 'Q (Mj x 10)')


subplot(2,6,[10,12])
xlabel('time (s)')
ax2 = gca;

line(t, Alpha,'Parent',ax2,'Color','k', 'LineStyle','-')

line(t, flapdeflection,'Parent',ax2,'Color','k', 'LineStyle','--')


line(t, mfuel./(10^2),'Parent',ax2,'Color','k', 'LineStyle','-.')


line(t, Isp./(10^2),'Parent',ax2,'Color','k', 'LineStyle',':', 'lineWidth', 2.0)



legend(ax2, 'AoA (degrees)','Flap Deflection (degrees)', 'Fuel Mass (kg x 10^2)', 'Isp (s x 10^2)')



% hold on
% subplot(2,5,[6,10])
% plot(t, Alpha)



% 
% %------ Forward Simulation -----------
% 
% % potentially need to replace this with CADAC
% 
% % Import Controls, Time and Initial States
% % these are the only things carried over from the PS method
% tau_Forward = tau;
% Mc_Forward = Mc;
% t_Forward = t;
% h_Forward(1) = h(1);
% v_Forward(1) = v(1);
% vh_Forward(1) = vh(1);
% vv_Forward(1) = vv(1);
% omega_Forward(1) = omega(1);
% theta_Forward(1) = theta(1);
% %--------------


% Iy_Forward = 1.;
% m_Forward = 1000.;
% 
% Fx_Forward = 0.; %Taking these out for testing
% Fz_Forward = 0.;
% My_Forward = 0.;




% simple forward method
% for i=2:length(Mc_Forward)
% omegadot_Forward(i-1) = (My_Forward  + Mc_Forward(i-1))/Iy_Forward;
% omega_Forward(i) = omegadot_Forward(i-1)*(t_Forward(i) - t_Forward(i-1)) + omega_Forward(i-1);
% 
% thetadot_Forward(i-1) = omega_Forward(i-1);
% theta_Forward(i) = thetadot_Forward(i-1)*(t_Forward(i) - t_Forward(i-1)) + theta_Forward(i-1);
% 
%     
% vhdot_Forward(i-1) = (Fx_Forward.*cos(theta_Forward(i-1)) + Fz_Forward.*sin(theta_Forward(i-1))  + tau_Forward(i-1).*cos(theta_Forward(i-1)))/m_Forward;
% vh_Forward(i) = vhdot_Forward(i-1)*(t_Forward(i) - t_Forward(i-1)) + vh_Forward(i-1);
% 
% vvdot_Forward(i-1) = (-Fx_Forward.*sin(theta_Forward(i-1)) + Fz_Forward.*cos(theta_Forward(i-1))  + tau_Forward(i-1).*sin(theta_Forward(i-1)))/m_Forward;
% vv_Forward(i) = vvdot_Forward(i-1)*(t_Forward(i) - t_Forward(i-1)) + vv_Forward(i-1);
% 
% 
% hdot_Forward(i-1) = vh_Forward(i-1);
% h_Forward(i) = hdot_Forward(i-1)*(t_Forward(i) - t_Forward(i-1)) + h_Forward(i-1);
% 
% vdot_Forward(i-1) = vv_Forward(i-1);
% v_Forward(i) = vdot_Forward(i-1)*(t_Forward(i) - t_Forward(i-1)) + v_Forward(i-1);
% 
% end
% 
% 
% figure(2)
% plot(h_Forward, v_Forward)






primal_old = primal;




